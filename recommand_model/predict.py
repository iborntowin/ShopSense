# -*- coding: utf-8 -*-
"""predict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/171hkhdfqj2Dazo2a4pnTiXB58mJjeMP7
"""

"""
predict.py
==========
Loads trained models and provides recommendation functionality.

Usage:
    from predict import get_recommendations

    result = get_recommendations(customer_id=100, top_n=5)
    print(result)
"""

import pickle
import joblib
import numpy as np
import pandas as pd
from collections import Counter
import warnings
warnings.filterwarnings('ignore')

# ============================================================
# LOAD MODEL ARTIFACTS (once at module import)
# ============================================================

print("üîÑ Loading recommendation models...")

try:
    # Get the directory of this script
    import os
    script_dir = os.path.dirname(os.path.abspath(__file__))
    models_dir = os.path.join(script_dir, 'models')
    
    # Load all 4 model files
    recommendation_engine = pickle.load(open(os.path.join(models_dir, 'recommendation_engine.pkl'), 'rb'))
    feature_scaler = joblib.load(os.path.join(models_dir, 'feature_scaler.pkl'))
    kmeans_model = joblib.load(os.path.join(models_dir, 'kmeans_model.pkl'))
    feature_info = joblib.load(os.path.join(models_dir, 'feature_info.pkl'))

    # Extract components
    df = recommendation_engine['df']
    X_features = recommendation_engine['X_features']
    customer_similarity = recommendation_engine['customer_similarity']
    item_similarity_df = recommendation_engine['item_similarity_df']
    cluster_features = recommendation_engine['cluster_features']
    item_list = recommendation_engine['item_list']

    # Get default weights
    default_weights = feature_info['weights']

    print("‚úÖ Models loaded successfully")
    print(f"   ‚Üí {len(df)} customers in database")
    print(f"   ‚Üí {len(item_list)} items available")
    print(f"   ‚Üí {kmeans_model.n_clusters} customer segments")

except Exception as e:
    print(f"‚ùå Error loading models: {e}")
    print("   Make sure you've run train_model.py first!")
    raise

# ============================================================
# MAIN RECOMMENDATION FUNCTION
# ============================================================

def get_recommendations(customer_id, top_n=5, weights=None):
    """
    Generate hybrid recommendations for a customer.

    Args:
        customer_id (int): Customer ID to generate recommendations for
        top_n (int): Number of recommendations to return (default: 5)
        weights (dict): Optional custom weights for hybrid model
                       Keys: 'content', 'segment', 'item_similarity'
                       Default: {'content': 0.4, 'segment': 0.4, 'item_similarity': 0.2}

    Returns:
        dict: {
            'customer_id': int,
            'purchased_item': str,
            'segment': int,
            'recommendations': [
                {'rank': int, 'item': str, 'score': float},
                ...
            ],
            'status': 'success'
        }

        OR (if error):
        {
            'error': str,
            'status': 'error'
        }
    """

    # Use default weights if not provided
    if weights is None:
        weights = default_weights.copy()

    # Validate customer exists
    if customer_id not in df['Customer ID'].values:
        return {
            'error': f"Customer ID {customer_id} not found in database",
            'status': 'error',
            'available_range': f"Valid IDs: {df['Customer ID'].min()} to {df['Customer ID'].max()}"
        }

    try:
        # Get customer data
        idx = df[df['Customer ID'] == customer_id].index[0]
        purchased_item = df.iloc[idx]['Purchased_Item']
        customer_segment = df.iloc[idx]['Customer_Segment']

        # Check if customer has purchased item
        if pd.isna(purchased_item):
            return {
                'error': f"Customer {customer_id} has no purchase history",
                'status': 'error',
                'segment': int(customer_segment),
                'suggestion': 'Use segment-based recommendations for new customers'
            }

        item_scores = {}

        # ========== COMPONENT 1: CONTENT-BASED SCORING ==========
        similarity_scores = list(enumerate(customer_similarity[idx]))
        similarity_scores = sorted(similarity_scores, key=lambda x: x[1], reverse=True)
        similar_customers = [i[0] for i in similarity_scores[1:51]]  # Top 50 similar

        similar_purchases = df.iloc[similar_customers]['Purchased_Item']
        item_counts = Counter(similar_purchases)

        # Remove already purchased item
        if purchased_item in item_counts:
            del item_counts[purchased_item]

        # Add content-based scores
        for item, count in item_counts.items():
            if pd.notna(item):
                item_scores[item] = item_scores.get(item, 0) + (count/len(similar_customers)) * weights['content']

        # ========== COMPONENT 2: SEGMENT-BASED SCORING ==========
        segment_customers = df[df['Customer_Segment'] == customer_segment]
        segment_item_counts = Counter(segment_customers['Purchased_Item'])

        # Remove already purchased item
        if purchased_item in segment_item_counts:
            del segment_item_counts[purchased_item]

        # Add segment-based scores
        for item, count in segment_item_counts.items():
            if pd.notna(item):
                item_scores[item] = item_scores.get(item, 0) + (count/len(segment_customers)) * weights['segment']

        # ========== COMPONENT 3: ITEM SIMILARITY SCORING ==========
        if purchased_item in item_similarity_df.index:
            similar_items = item_similarity_df[purchased_item].sort_values(ascending=False)[1:11]
            for item, similarity in similar_items.items():
                item_scores[item] = item_scores.get(item, 0) + similarity * weights['item_similarity']

        # ========== COMBINE AND RANK ==========
        sorted_items = sorted(item_scores.items(), key=lambda x: x[1], reverse=True)[:top_n]

        # Format output
        return {
            'customer_id': int(customer_id),
            'purchased_item': purchased_item,
            'segment': int(customer_segment),
            'segment_size': int(len(segment_customers)),
            'recommendations': [
                {
                    'rank': i + 1,
                    'item': item,
                    'score': float(score)
                }
                for i, (item, score) in enumerate(sorted_items)
            ],
            'weights_used': weights,
            'status': 'success'
        }

    except Exception as e:
        return {
            'error': f"Prediction failed: {str(e)}",
            'status': 'error',
            'customer_id': customer_id
        }


def get_available_items():
    """
    Get list of all available items in the catalog.

    Returns:
        list: Sorted list of item names
    """
    return item_list.copy()


def get_customer_info(customer_id):
    """
    Get basic information about a customer.

    Args:
        customer_id (int): Customer ID

    Returns:
        dict: Customer information or error
    """
    if customer_id not in df['Customer ID'].values:
        return {
            'error': f"Customer ID {customer_id} not found",
            'status': 'error'
        }

    customer_data = df[df['Customer ID'] == customer_id].iloc[0]

    return {
        'customer_id': int(customer_id),
        'purchased_item': customer_data['Purchased_Item'],
        'segment': int(customer_data['Customer_Segment']),
        'status': 'success'
    }


def get_segment_popular_items(segment_id, top_n=10):
    """
    Get most popular items in a specific segment.

    Args:
        segment_id (int): Segment ID (0-3)
        top_n (int): Number of items to return

    Returns:
        dict: Popular items in segment
    """
    if segment_id not in range(kmeans_model.n_clusters):
        return {
            'error': f"Invalid segment ID. Must be 0-{kmeans_model.n_clusters-1}",
            'status': 'error'
        }

    segment_customers = df[df['Customer_Segment'] == segment_id]
    item_counts = Counter(segment_customers['Purchased_Item'].dropna())
    popular_items = item_counts.most_common(top_n)

    return {
        'segment': segment_id,
        'segment_size': len(segment_customers),
        'popular_items': [
            {
                'rank': i + 1,
                'item': item,
                'purchases': count,
                'popularity': float(count / len(segment_customers))
            }
            for i, (item, count) in enumerate(popular_items)
        ],
        'status': 'success'
    }


# ============================================================
# TEST THE PREDICTION FUNCTION
# ============================================================

if __name__ == "__main__":
    print("\n" + "="*60)
    print("üß™ TESTING PREDICTION FUNCTION")
    print("="*60)

    # Test 1: Normal recommendation
    print("\nüìä Test 1: Get recommendations for Customer 100")
    result = get_recommendations(customer_id=100, top_n=5)

    if result['status'] == 'success':
        print(f"‚úÖ Success!")
        print(f"   Customer: {result['customer_id']}")
        print(f"   Purchased: {result['purchased_item']}")
        print(f"   Segment: {result['segment']}")
        print(f"\n   Top {len(result['recommendations'])} Recommendations:")
        for rec in result['recommendations']:
            print(f"      {rec['rank']}. {rec['item']:15} (Score: {rec['score']:.4f})")
    else:
        print(f"‚ùå Error: {result['error']}")

    # Test 2: Invalid customer
    print("\nüìä Test 2: Invalid customer ID")
    result = get_recommendations(customer_id=99999)
    print(f"   Status: {result['status']}")
    print(f"   Message: {result.get('error', 'N/A')}")

    # Test 3: Get catalog
    print("\nüìä Test 3: Get available items")
    items = get_available_items()
    print(f"   Total items: {len(items)}")
    print(f"   Sample items: {items[:5]}")

    # Test 4: Segment popularity
    print("\nüìä Test 4: Popular items in Segment 0")
    result = get_segment_popular_items(segment_id=0, top_n=5)
    if result['status'] == 'success':
        print(f"   Segment size: {result['segment_size']} customers")
        print(f"   Top 5 items:")
        for item in result['popular_items']:
            print(f"      {item['rank']}. {item['item']:15} ({item['purchases']} purchases)")

    print("\n" + "="*60)
    print("‚úÖ PREDICTION MODULE READY")
    print("="*60)